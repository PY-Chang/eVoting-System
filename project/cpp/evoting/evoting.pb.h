// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: evoting.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_evoting_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_evoting_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_evoting_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_evoting_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_evoting_2eproto;
namespace voting {
class AuthRequest;
struct AuthRequestDefaultTypeInternal;
extern AuthRequestDefaultTypeInternal _AuthRequest_default_instance_;
class AuthToken;
struct AuthTokenDefaultTypeInternal;
extern AuthTokenDefaultTypeInternal _AuthToken_default_instance_;
class Challenge;
struct ChallengeDefaultTypeInternal;
extern ChallengeDefaultTypeInternal _Challenge_default_instance_;
class Election;
struct ElectionDefaultTypeInternal;
extern ElectionDefaultTypeInternal _Election_default_instance_;
class ElectionName;
struct ElectionNameDefaultTypeInternal;
extern ElectionNameDefaultTypeInternal _ElectionName_default_instance_;
class ElectionResult;
struct ElectionResultDefaultTypeInternal;
extern ElectionResultDefaultTypeInternal _ElectionResult_default_instance_;
class ElectionStatus;
struct ElectionStatusDefaultTypeInternal;
extern ElectionStatusDefaultTypeInternal _ElectionStatus_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class Vote;
struct VoteDefaultTypeInternal;
extern VoteDefaultTypeInternal _Vote_default_instance_;
class VoteCount;
struct VoteCountDefaultTypeInternal;
extern VoteCountDefaultTypeInternal _VoteCount_default_instance_;
class VoteStatus;
struct VoteStatusDefaultTypeInternal;
extern VoteStatusDefaultTypeInternal _VoteStatus_default_instance_;
class Voter;
struct VoterDefaultTypeInternal;
extern VoterDefaultTypeInternal _Voter_default_instance_;
class VoterName;
struct VoterNameDefaultTypeInternal;
extern VoterNameDefaultTypeInternal _VoterName_default_instance_;
}  // namespace voting
PROTOBUF_NAMESPACE_OPEN
template<> ::voting::AuthRequest* Arena::CreateMaybeMessage<::voting::AuthRequest>(Arena*);
template<> ::voting::AuthToken* Arena::CreateMaybeMessage<::voting::AuthToken>(Arena*);
template<> ::voting::Challenge* Arena::CreateMaybeMessage<::voting::Challenge>(Arena*);
template<> ::voting::Election* Arena::CreateMaybeMessage<::voting::Election>(Arena*);
template<> ::voting::ElectionName* Arena::CreateMaybeMessage<::voting::ElectionName>(Arena*);
template<> ::voting::ElectionResult* Arena::CreateMaybeMessage<::voting::ElectionResult>(Arena*);
template<> ::voting::ElectionStatus* Arena::CreateMaybeMessage<::voting::ElectionStatus>(Arena*);
template<> ::voting::Response* Arena::CreateMaybeMessage<::voting::Response>(Arena*);
template<> ::voting::Vote* Arena::CreateMaybeMessage<::voting::Vote>(Arena*);
template<> ::voting::VoteCount* Arena::CreateMaybeMessage<::voting::VoteCount>(Arena*);
template<> ::voting::VoteStatus* Arena::CreateMaybeMessage<::voting::VoteStatus>(Arena*);
template<> ::voting::Voter* Arena::CreateMaybeMessage<::voting::Voter>(Arena*);
template<> ::voting::VoterName* Arena::CreateMaybeMessage<::voting::VoterName>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace voting {

// ===================================================================

class Voter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.Voter) */ {
 public:
  inline Voter() : Voter(nullptr) {}
  ~Voter() override;
  explicit constexpr Voter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Voter(const Voter& from);
  Voter(Voter&& from) noexcept
    : Voter() {
    *this = ::std::move(from);
  }

  inline Voter& operator=(const Voter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Voter& operator=(Voter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Voter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Voter* internal_default_instance() {
    return reinterpret_cast<const Voter*>(
               &_Voter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Voter& a, Voter& b) {
    a.Swap(&b);
  }
  inline void Swap(Voter* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Voter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Voter* New() const final {
    return new Voter();
  }

  Voter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Voter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Voter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Voter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Voter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.Voter";
  }
  protected:
  explicit Voter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kGroupFieldNumber = 2,
    kPublicKeyFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required string group = 2;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const std::string& group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group();
  PROTOBUF_MUST_USE_RESULT std::string* release_group();
  void set_allocated_group(std::string* group);
  private:
  const std::string& _internal_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group(const std::string& value);
  std::string* _internal_mutable_group();
  public:

  // required bytes public_key = 3;
  bool has_public_key() const;
  private:
  bool _internal_has_public_key() const;
  public:
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:voting.Voter)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  friend struct ::TableStruct_evoting_2eproto;
};
// -------------------------------------------------------------------

class VoterName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.VoterName) */ {
 public:
  inline VoterName() : VoterName(nullptr) {}
  ~VoterName() override;
  explicit constexpr VoterName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoterName(const VoterName& from);
  VoterName(VoterName&& from) noexcept
    : VoterName() {
    *this = ::std::move(from);
  }

  inline VoterName& operator=(const VoterName& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoterName& operator=(VoterName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoterName& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoterName* internal_default_instance() {
    return reinterpret_cast<const VoterName*>(
               &_VoterName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(VoterName& a, VoterName& b) {
    a.Swap(&b);
  }
  inline void Swap(VoterName* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoterName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VoterName* New() const final {
    return new VoterName();
  }

  VoterName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VoterName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoterName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VoterName& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoterName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.VoterName";
  }
  protected:
  explicit VoterName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:voting.VoterName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_evoting_2eproto;
};
// -------------------------------------------------------------------

class VoteStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.VoteStatus) */ {
 public:
  inline VoteStatus() : VoteStatus(nullptr) {}
  ~VoteStatus() override;
  explicit constexpr VoteStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteStatus(const VoteStatus& from);
  VoteStatus(VoteStatus&& from) noexcept
    : VoteStatus() {
    *this = ::std::move(from);
  }

  inline VoteStatus& operator=(const VoteStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteStatus& operator=(VoteStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteStatus* internal_default_instance() {
    return reinterpret_cast<const VoteStatus*>(
               &_VoteStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(VoteStatus& a, VoteStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VoteStatus* New() const final {
    return new VoteStatus();
  }

  VoteStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VoteStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoteStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VoteStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.VoteStatus";
  }
  protected:
  explicit VoteStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // required int32 code = 1;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:voting.VoteStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  friend struct ::TableStruct_evoting_2eproto;
};
// -------------------------------------------------------------------

class Challenge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.Challenge) */ {
 public:
  inline Challenge() : Challenge(nullptr) {}
  ~Challenge() override;
  explicit constexpr Challenge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Challenge(const Challenge& from);
  Challenge(Challenge&& from) noexcept
    : Challenge() {
    *this = ::std::move(from);
  }

  inline Challenge& operator=(const Challenge& from) {
    CopyFrom(from);
    return *this;
  }
  inline Challenge& operator=(Challenge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Challenge& default_instance() {
    return *internal_default_instance();
  }
  static inline const Challenge* internal_default_instance() {
    return reinterpret_cast<const Challenge*>(
               &_Challenge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Challenge& a, Challenge& b) {
    a.Swap(&b);
  }
  inline void Swap(Challenge* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Challenge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Challenge* New() const final {
    return new Challenge();
  }

  Challenge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Challenge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Challenge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Challenge& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Challenge* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.Challenge";
  }
  protected:
  explicit Challenge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // required bytes value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:voting.Challenge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_evoting_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit constexpr Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const final {
    return new Response();
  }

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // required bytes value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:voting.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_evoting_2eproto;
};
// -------------------------------------------------------------------

class AuthToken final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.AuthToken) */ {
 public:
  inline AuthToken() : AuthToken(nullptr) {}
  ~AuthToken() override;
  explicit constexpr AuthToken(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthToken(const AuthToken& from);
  AuthToken(AuthToken&& from) noexcept
    : AuthToken() {
    *this = ::std::move(from);
  }

  inline AuthToken& operator=(const AuthToken& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthToken& operator=(AuthToken&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthToken& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthToken* internal_default_instance() {
    return reinterpret_cast<const AuthToken*>(
               &_AuthToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AuthToken& a, AuthToken& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthToken* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthToken* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthToken* New() const final {
    return new AuthToken();
  }

  AuthToken* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthToken>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthToken& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthToken& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthToken* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.AuthToken";
  }
  protected:
  explicit AuthToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // required bytes value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:voting.AuthToken)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_evoting_2eproto;
};
// -------------------------------------------------------------------

class Election final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.Election) */ {
 public:
  inline Election() : Election(nullptr) {}
  ~Election() override;
  explicit constexpr Election(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Election(const Election& from);
  Election(Election&& from) noexcept
    : Election() {
    *this = ::std::move(from);
  }

  inline Election& operator=(const Election& from) {
    CopyFrom(from);
    return *this;
  }
  inline Election& operator=(Election&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Election& default_instance() {
    return *internal_default_instance();
  }
  static inline const Election* internal_default_instance() {
    return reinterpret_cast<const Election*>(
               &_Election_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Election& a, Election& b) {
    a.Swap(&b);
  }
  inline void Swap(Election* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Election* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Election* New() const final {
    return new Election();
  }

  Election* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Election>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Election& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Election& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Election* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.Election";
  }
  protected:
  explicit Election(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 2,
    kChoicesFieldNumber = 3,
    kNameFieldNumber = 1,
    kEndDateFieldNumber = 4,
    kTokenFieldNumber = 5,
  };
  // repeated string groups = 2;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  const std::string& groups(int index) const;
  std::string* mutable_groups(int index);
  void set_groups(int index, const std::string& value);
  void set_groups(int index, std::string&& value);
  void set_groups(int index, const char* value);
  void set_groups(int index, const char* value, size_t size);
  std::string* add_groups();
  void add_groups(const std::string& value);
  void add_groups(std::string&& value);
  void add_groups(const char* value);
  void add_groups(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& groups() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_groups();
  private:
  const std::string& _internal_groups(int index) const;
  std::string* _internal_add_groups();
  public:

  // repeated string choices = 3;
  int choices_size() const;
  private:
  int _internal_choices_size() const;
  public:
  void clear_choices();
  const std::string& choices(int index) const;
  std::string* mutable_choices(int index);
  void set_choices(int index, const std::string& value);
  void set_choices(int index, std::string&& value);
  void set_choices(int index, const char* value);
  void set_choices(int index, const char* value, size_t size);
  std::string* add_choices();
  void add_choices(const std::string& value);
  void add_choices(std::string&& value);
  void add_choices(const char* value);
  void add_choices(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& choices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_choices();
  private:
  const std::string& _internal_choices(int index) const;
  std::string* _internal_add_choices();
  public:

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required .google.protobuf.Timestamp end_date = 4;
  bool has_end_date() const;
  private:
  bool _internal_has_end_date() const;
  public:
  void clear_end_date();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& end_date() const;
  PROTOBUF_MUST_USE_RESULT ::PROTOBUF_NAMESPACE_ID::Timestamp* release_end_date();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_end_date();
  void set_allocated_end_date(::PROTOBUF_NAMESPACE_ID::Timestamp* end_date);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_end_date() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_end_date();
  public:
  void unsafe_arena_set_allocated_end_date(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* end_date);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_end_date();

  // required .voting.AuthToken token = 5;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::voting::AuthToken& token() const;
  PROTOBUF_MUST_USE_RESULT ::voting::AuthToken* release_token();
  ::voting::AuthToken* mutable_token();
  void set_allocated_token(::voting::AuthToken* token);
  private:
  const ::voting::AuthToken& _internal_token() const;
  ::voting::AuthToken* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::voting::AuthToken* token);
  ::voting::AuthToken* unsafe_arena_release_token();

  // @@protoc_insertion_point(class_scope:voting.Election)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> groups_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> choices_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* end_date_;
  ::voting::AuthToken* token_;
  friend struct ::TableStruct_evoting_2eproto;
};
// -------------------------------------------------------------------

class ElectionStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.ElectionStatus) */ {
 public:
  inline ElectionStatus() : ElectionStatus(nullptr) {}
  ~ElectionStatus() override;
  explicit constexpr ElectionStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElectionStatus(const ElectionStatus& from);
  ElectionStatus(ElectionStatus&& from) noexcept
    : ElectionStatus() {
    *this = ::std::move(from);
  }

  inline ElectionStatus& operator=(const ElectionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElectionStatus& operator=(ElectionStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ElectionStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElectionStatus* internal_default_instance() {
    return reinterpret_cast<const ElectionStatus*>(
               &_ElectionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ElectionStatus& a, ElectionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ElectionStatus* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElectionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ElectionStatus* New() const final {
    return new ElectionStatus();
  }

  ElectionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ElectionStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ElectionStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ElectionStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElectionStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.ElectionStatus";
  }
  protected:
  explicit ElectionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // required int32 code = 1;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:voting.ElectionStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  friend struct ::TableStruct_evoting_2eproto;
};
// -------------------------------------------------------------------

class Vote final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.Vote) */ {
 public:
  inline Vote() : Vote(nullptr) {}
  ~Vote() override;
  explicit constexpr Vote(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vote(const Vote& from);
  Vote(Vote&& from) noexcept
    : Vote() {
    *this = ::std::move(from);
  }

  inline Vote& operator=(const Vote& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vote& operator=(Vote&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vote& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vote* internal_default_instance() {
    return reinterpret_cast<const Vote*>(
               &_Vote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Vote& a, Vote& b) {
    a.Swap(&b);
  }
  inline void Swap(Vote* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vote* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vote* New() const final {
    return new Vote();
  }

  Vote* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vote>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vote& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vote& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vote* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.Vote";
  }
  protected:
  explicit Vote(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElectionNameFieldNumber = 1,
    kChoiceNameFieldNumber = 2,
    kTokenFieldNumber = 3,
  };
  // required string election_name = 1;
  bool has_election_name() const;
  private:
  bool _internal_has_election_name() const;
  public:
  void clear_election_name();
  const std::string& election_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_election_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_election_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_election_name();
  void set_allocated_election_name(std::string* election_name);
  private:
  const std::string& _internal_election_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_election_name(const std::string& value);
  std::string* _internal_mutable_election_name();
  public:

  // required string choice_name = 2;
  bool has_choice_name() const;
  private:
  bool _internal_has_choice_name() const;
  public:
  void clear_choice_name();
  const std::string& choice_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_choice_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_choice_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_choice_name();
  void set_allocated_choice_name(std::string* choice_name);
  private:
  const std::string& _internal_choice_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_choice_name(const std::string& value);
  std::string* _internal_mutable_choice_name();
  public:

  // required .voting.AuthToken token = 3;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::voting::AuthToken& token() const;
  PROTOBUF_MUST_USE_RESULT ::voting::AuthToken* release_token();
  ::voting::AuthToken* mutable_token();
  void set_allocated_token(::voting::AuthToken* token);
  private:
  const ::voting::AuthToken& _internal_token() const;
  ::voting::AuthToken* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::voting::AuthToken* token);
  ::voting::AuthToken* unsafe_arena_release_token();

  // @@protoc_insertion_point(class_scope:voting.Vote)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr election_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr choice_name_;
  ::voting::AuthToken* token_;
  friend struct ::TableStruct_evoting_2eproto;
};
// -------------------------------------------------------------------

class AuthRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.AuthRequest) */ {
 public:
  inline AuthRequest() : AuthRequest(nullptr) {}
  ~AuthRequest() override;
  explicit constexpr AuthRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthRequest(const AuthRequest& from);
  AuthRequest(AuthRequest&& from) noexcept
    : AuthRequest() {
    *this = ::std::move(from);
  }

  inline AuthRequest& operator=(const AuthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthRequest& operator=(AuthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthRequest* internal_default_instance() {
    return reinterpret_cast<const AuthRequest*>(
               &_AuthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AuthRequest& a, AuthRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AuthRequest* New() const final {
    return new AuthRequest();
  }

  AuthRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AuthRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AuthRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.AuthRequest";
  }
  protected:
  explicit AuthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // required bytes value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:voting.AuthRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_evoting_2eproto;
};
// -------------------------------------------------------------------

class ElectionName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.ElectionName) */ {
 public:
  inline ElectionName() : ElectionName(nullptr) {}
  ~ElectionName() override;
  explicit constexpr ElectionName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElectionName(const ElectionName& from);
  ElectionName(ElectionName&& from) noexcept
    : ElectionName() {
    *this = ::std::move(from);
  }

  inline ElectionName& operator=(const ElectionName& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElectionName& operator=(ElectionName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ElectionName& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElectionName* internal_default_instance() {
    return reinterpret_cast<const ElectionName*>(
               &_ElectionName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ElectionName& a, ElectionName& b) {
    a.Swap(&b);
  }
  inline void Swap(ElectionName* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElectionName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ElectionName* New() const final {
    return new ElectionName();
  }

  ElectionName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ElectionName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ElectionName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ElectionName& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElectionName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.ElectionName";
  }
  protected:
  explicit ElectionName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:voting.ElectionName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_evoting_2eproto;
};
// -------------------------------------------------------------------

class VoteCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.VoteCount) */ {
 public:
  inline VoteCount() : VoteCount(nullptr) {}
  ~VoteCount() override;
  explicit constexpr VoteCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoteCount(const VoteCount& from);
  VoteCount(VoteCount&& from) noexcept
    : VoteCount() {
    *this = ::std::move(from);
  }

  inline VoteCount& operator=(const VoteCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoteCount& operator=(VoteCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoteCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoteCount* internal_default_instance() {
    return reinterpret_cast<const VoteCount*>(
               &_VoteCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VoteCount& a, VoteCount& b) {
    a.Swap(&b);
  }
  inline void Swap(VoteCount* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoteCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VoteCount* New() const final {
    return new VoteCount();
  }

  VoteCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VoteCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoteCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VoteCount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoteCount* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.VoteCount";
  }
  protected:
  explicit VoteCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChoiceNameFieldNumber = 1,
    kTokenFieldNumber = 3,
    kCountFieldNumber = 2,
  };
  // required string choice_name = 1;
  bool has_choice_name() const;
  private:
  bool _internal_has_choice_name() const;
  public:
  void clear_choice_name();
  const std::string& choice_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_choice_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_choice_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_choice_name();
  void set_allocated_choice_name(std::string* choice_name);
  private:
  const std::string& _internal_choice_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_choice_name(const std::string& value);
  std::string* _internal_mutable_choice_name();
  public:

  // required .voting.AuthToken token = 3;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::voting::AuthToken& token() const;
  PROTOBUF_MUST_USE_RESULT ::voting::AuthToken* release_token();
  ::voting::AuthToken* mutable_token();
  void set_allocated_token(::voting::AuthToken* token);
  private:
  const ::voting::AuthToken& _internal_token() const;
  ::voting::AuthToken* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::voting::AuthToken* token);
  ::voting::AuthToken* unsafe_arena_release_token();

  // required int32 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::int32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:voting.VoteCount)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr choice_name_;
  ::voting::AuthToken* token_;
  ::PROTOBUF_NAMESPACE_ID::int32 count_;
  friend struct ::TableStruct_evoting_2eproto;
};
// -------------------------------------------------------------------

class ElectionResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:voting.ElectionResult) */ {
 public:
  inline ElectionResult() : ElectionResult(nullptr) {}
  ~ElectionResult() override;
  explicit constexpr ElectionResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ElectionResult(const ElectionResult& from);
  ElectionResult(ElectionResult&& from) noexcept
    : ElectionResult() {
    *this = ::std::move(from);
  }

  inline ElectionResult& operator=(const ElectionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ElectionResult& operator=(ElectionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ElectionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ElectionResult* internal_default_instance() {
    return reinterpret_cast<const ElectionResult*>(
               &_ElectionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ElectionResult& a, ElectionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ElectionResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ElectionResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ElectionResult* New() const final {
    return new ElectionResult();
  }

  ElectionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ElectionResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ElectionResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ElectionResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ElectionResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "voting.ElectionResult";
  }
  protected:
  explicit ElectionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated .voting.VoteCount count = 2;
  int count_size() const;
  private:
  int _internal_count_size() const;
  public:
  void clear_count();
  ::voting::VoteCount* mutable_count(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::VoteCount >*
      mutable_count();
  private:
  const ::voting::VoteCount& _internal_count(int index) const;
  ::voting::VoteCount* _internal_add_count();
  public:
  const ::voting::VoteCount& count(int index) const;
  ::voting::VoteCount* add_count();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::VoteCount >&
      count() const;

  // required int32 status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:voting.ElectionResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::VoteCount > count_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  friend struct ::TableStruct_evoting_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Voter

// required string name = 1;
inline bool Voter::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Voter::has_name() const {
  return _internal_has_name();
}
inline void Voter::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Voter::name() const {
  // @@protoc_insertion_point(field_get:voting.Voter.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Voter::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.Voter.name)
}
inline std::string* Voter::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:voting.Voter.name)
  return _s;
}
inline const std::string& Voter::_internal_name() const {
  return name_.Get();
}
inline void Voter::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Voter::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Voter::release_name() {
  // @@protoc_insertion_point(field_release:voting.Voter.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Voter::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:voting.Voter.name)
}

// required string group = 2;
inline bool Voter::_internal_has_group() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Voter::has_group() const {
  return _internal_has_group();
}
inline void Voter::clear_group() {
  group_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Voter::group() const {
  // @@protoc_insertion_point(field_get:voting.Voter.group)
  return _internal_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Voter::set_group(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.Voter.group)
}
inline std::string* Voter::mutable_group() {
  std::string* _s = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:voting.Voter.group)
  return _s;
}
inline const std::string& Voter::_internal_group() const {
  return group_.Get();
}
inline void Voter::_internal_set_group(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Voter::_internal_mutable_group() {
  _has_bits_[0] |= 0x00000002u;
  return group_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Voter::release_group() {
  // @@protoc_insertion_point(field_release:voting.Voter.group)
  if (!_internal_has_group()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return group_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Voter::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  group_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:voting.Voter.group)
}

// required bytes public_key = 3;
inline bool Voter::_internal_has_public_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Voter::has_public_key() const {
  return _internal_has_public_key();
}
inline void Voter::clear_public_key() {
  public_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Voter::public_key() const {
  // @@protoc_insertion_point(field_get:voting.Voter.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Voter::set_public_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 public_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.Voter.public_key)
}
inline std::string* Voter::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:voting.Voter.public_key)
  return _s;
}
inline const std::string& Voter::_internal_public_key() const {
  return public_key_.Get();
}
inline void Voter::_internal_set_public_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Voter::_internal_mutable_public_key() {
  _has_bits_[0] |= 0x00000004u;
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Voter::release_public_key() {
  // @@protoc_insertion_point(field_release:voting.Voter.public_key)
  if (!_internal_has_public_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return public_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Voter::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:voting.Voter.public_key)
}

// -------------------------------------------------------------------

// VoterName

// required string name = 1;
inline bool VoterName::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VoterName::has_name() const {
  return _internal_has_name();
}
inline void VoterName::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VoterName::name() const {
  // @@protoc_insertion_point(field_get:voting.VoterName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoterName::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.VoterName.name)
}
inline std::string* VoterName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:voting.VoterName.name)
  return _s;
}
inline const std::string& VoterName::_internal_name() const {
  return name_.Get();
}
inline void VoterName::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoterName::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoterName::release_name() {
  // @@protoc_insertion_point(field_release:voting.VoterName.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoterName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:voting.VoterName.name)
}

// -------------------------------------------------------------------

// VoteStatus

// required int32 code = 1;
inline bool VoteStatus::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VoteStatus::has_code() const {
  return _internal_has_code();
}
inline void VoteStatus::clear_code() {
  code_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VoteStatus::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VoteStatus::code() const {
  // @@protoc_insertion_point(field_get:voting.VoteStatus.code)
  return _internal_code();
}
inline void VoteStatus::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  code_ = value;
}
inline void VoteStatus::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:voting.VoteStatus.code)
}

// -------------------------------------------------------------------

// Challenge

// required bytes value = 1;
inline bool Challenge::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Challenge::has_value() const {
  return _internal_has_value();
}
inline void Challenge::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Challenge::value() const {
  // @@protoc_insertion_point(field_get:voting.Challenge.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Challenge::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.Challenge.value)
}
inline std::string* Challenge::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:voting.Challenge.value)
  return _s;
}
inline const std::string& Challenge::_internal_value() const {
  return value_.Get();
}
inline void Challenge::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Challenge::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Challenge::release_value() {
  // @@protoc_insertion_point(field_release:voting.Challenge.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Challenge::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:voting.Challenge.value)
}

// -------------------------------------------------------------------

// Response

// required bytes value = 1;
inline bool Response::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Response::has_value() const {
  return _internal_has_value();
}
inline void Response::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Response::value() const {
  // @@protoc_insertion_point(field_get:voting.Response.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Response::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.Response.value)
}
inline std::string* Response::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:voting.Response.value)
  return _s;
}
inline const std::string& Response::_internal_value() const {
  return value_.Get();
}
inline void Response::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Response::release_value() {
  // @@protoc_insertion_point(field_release:voting.Response.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Response::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:voting.Response.value)
}

// -------------------------------------------------------------------

// AuthToken

// required bytes value = 1;
inline bool AuthToken::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthToken::has_value() const {
  return _internal_has_value();
}
inline void AuthToken::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthToken::value() const {
  // @@protoc_insertion_point(field_get:voting.AuthToken.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthToken::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.AuthToken.value)
}
inline std::string* AuthToken::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:voting.AuthToken.value)
  return _s;
}
inline const std::string& AuthToken::_internal_value() const {
  return value_.Get();
}
inline void AuthToken::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthToken::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthToken::release_value() {
  // @@protoc_insertion_point(field_release:voting.AuthToken.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthToken::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:voting.AuthToken.value)
}

// -------------------------------------------------------------------

// Election

// required string name = 1;
inline bool Election::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Election::has_name() const {
  return _internal_has_name();
}
inline void Election::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Election::name() const {
  // @@protoc_insertion_point(field_get:voting.Election.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Election::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.Election.name)
}
inline std::string* Election::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:voting.Election.name)
  return _s;
}
inline const std::string& Election::_internal_name() const {
  return name_.Get();
}
inline void Election::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Election::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Election::release_name() {
  // @@protoc_insertion_point(field_release:voting.Election.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Election::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:voting.Election.name)
}

// repeated string groups = 2;
inline int Election::_internal_groups_size() const {
  return groups_.size();
}
inline int Election::groups_size() const {
  return _internal_groups_size();
}
inline void Election::clear_groups() {
  groups_.Clear();
}
inline std::string* Election::add_groups() {
  std::string* _s = _internal_add_groups();
  // @@protoc_insertion_point(field_add_mutable:voting.Election.groups)
  return _s;
}
inline const std::string& Election::_internal_groups(int index) const {
  return groups_.Get(index);
}
inline const std::string& Election::groups(int index) const {
  // @@protoc_insertion_point(field_get:voting.Election.groups)
  return _internal_groups(index);
}
inline std::string* Election::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:voting.Election.groups)
  return groups_.Mutable(index);
}
inline void Election::set_groups(int index, const std::string& value) {
  groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:voting.Election.groups)
}
inline void Election::set_groups(int index, std::string&& value) {
  groups_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:voting.Election.groups)
}
inline void Election::set_groups(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:voting.Election.groups)
}
inline void Election::set_groups(int index, const char* value, size_t size) {
  groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:voting.Election.groups)
}
inline std::string* Election::_internal_add_groups() {
  return groups_.Add();
}
inline void Election::add_groups(const std::string& value) {
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:voting.Election.groups)
}
inline void Election::add_groups(std::string&& value) {
  groups_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:voting.Election.groups)
}
inline void Election::add_groups(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:voting.Election.groups)
}
inline void Election::add_groups(const char* value, size_t size) {
  groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:voting.Election.groups)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Election::groups() const {
  // @@protoc_insertion_point(field_list:voting.Election.groups)
  return groups_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Election::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:voting.Election.groups)
  return &groups_;
}

// repeated string choices = 3;
inline int Election::_internal_choices_size() const {
  return choices_.size();
}
inline int Election::choices_size() const {
  return _internal_choices_size();
}
inline void Election::clear_choices() {
  choices_.Clear();
}
inline std::string* Election::add_choices() {
  std::string* _s = _internal_add_choices();
  // @@protoc_insertion_point(field_add_mutable:voting.Election.choices)
  return _s;
}
inline const std::string& Election::_internal_choices(int index) const {
  return choices_.Get(index);
}
inline const std::string& Election::choices(int index) const {
  // @@protoc_insertion_point(field_get:voting.Election.choices)
  return _internal_choices(index);
}
inline std::string* Election::mutable_choices(int index) {
  // @@protoc_insertion_point(field_mutable:voting.Election.choices)
  return choices_.Mutable(index);
}
inline void Election::set_choices(int index, const std::string& value) {
  choices_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:voting.Election.choices)
}
inline void Election::set_choices(int index, std::string&& value) {
  choices_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:voting.Election.choices)
}
inline void Election::set_choices(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  choices_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:voting.Election.choices)
}
inline void Election::set_choices(int index, const char* value, size_t size) {
  choices_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:voting.Election.choices)
}
inline std::string* Election::_internal_add_choices() {
  return choices_.Add();
}
inline void Election::add_choices(const std::string& value) {
  choices_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:voting.Election.choices)
}
inline void Election::add_choices(std::string&& value) {
  choices_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:voting.Election.choices)
}
inline void Election::add_choices(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  choices_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:voting.Election.choices)
}
inline void Election::add_choices(const char* value, size_t size) {
  choices_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:voting.Election.choices)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Election::choices() const {
  // @@protoc_insertion_point(field_list:voting.Election.choices)
  return choices_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Election::mutable_choices() {
  // @@protoc_insertion_point(field_mutable_list:voting.Election.choices)
  return &choices_;
}

// required .google.protobuf.Timestamp end_date = 4;
inline bool Election::_internal_has_end_date() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || end_date_ != nullptr);
  return value;
}
inline bool Election::has_end_date() const {
  return _internal_has_end_date();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Election::_internal_end_date() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = end_date_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Election::end_date() const {
  // @@protoc_insertion_point(field_get:voting.Election.end_date)
  return _internal_end_date();
}
inline void Election::unsafe_arena_set_allocated_end_date(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* end_date) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_date_);
  }
  end_date_ = end_date;
  if (end_date) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:voting.Election.end_date)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Election::release_end_date() {
  _has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_date_;
  end_date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Election::unsafe_arena_release_end_date() {
  // @@protoc_insertion_point(field_release:voting.Election.end_date)
  _has_bits_[0] &= ~0x00000002u;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = end_date_;
  end_date_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Election::_internal_mutable_end_date() {
  _has_bits_[0] |= 0x00000002u;
  if (end_date_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    end_date_ = p;
  }
  return end_date_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Election::mutable_end_date() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_end_date();
  // @@protoc_insertion_point(field_mutable:voting.Election.end_date)
  return _msg;
}
inline void Election::set_allocated_end_date(::PROTOBUF_NAMESPACE_ID::Timestamp* end_date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_date_);
  }
  if (end_date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_date));
    if (message_arena != submessage_arena) {
      end_date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end_date, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  end_date_ = end_date;
  // @@protoc_insertion_point(field_set_allocated:voting.Election.end_date)
}

// required .voting.AuthToken token = 5;
inline bool Election::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || token_ != nullptr);
  return value;
}
inline bool Election::has_token() const {
  return _internal_has_token();
}
inline void Election::clear_token() {
  if (token_ != nullptr) token_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::voting::AuthToken& Election::_internal_token() const {
  const ::voting::AuthToken* p = token_;
  return p != nullptr ? *p : reinterpret_cast<const ::voting::AuthToken&>(
      ::voting::_AuthToken_default_instance_);
}
inline const ::voting::AuthToken& Election::token() const {
  // @@protoc_insertion_point(field_get:voting.Election.token)
  return _internal_token();
}
inline void Election::unsafe_arena_set_allocated_token(
    ::voting::AuthToken* token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(token_);
  }
  token_ = token;
  if (token) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:voting.Election.token)
}
inline ::voting::AuthToken* Election::release_token() {
  _has_bits_[0] &= ~0x00000004u;
  ::voting::AuthToken* temp = token_;
  token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::voting::AuthToken* Election::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_release:voting.Election.token)
  _has_bits_[0] &= ~0x00000004u;
  ::voting::AuthToken* temp = token_;
  token_ = nullptr;
  return temp;
}
inline ::voting::AuthToken* Election::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000004u;
  if (token_ == nullptr) {
    auto* p = CreateMaybeMessage<::voting::AuthToken>(GetArenaForAllocation());
    token_ = p;
  }
  return token_;
}
inline ::voting::AuthToken* Election::mutable_token() {
  ::voting::AuthToken* _msg = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:voting.Election.token)
  return _msg;
}
inline void Election::set_allocated_token(::voting::AuthToken* token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete token_;
  }
  if (token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::voting::AuthToken>::GetOwningArena(token);
    if (message_arena != submessage_arena) {
      token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  token_ = token;
  // @@protoc_insertion_point(field_set_allocated:voting.Election.token)
}

// -------------------------------------------------------------------

// ElectionStatus

// required int32 code = 1;
inline bool ElectionStatus::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ElectionStatus::has_code() const {
  return _internal_has_code();
}
inline void ElectionStatus::clear_code() {
  code_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ElectionStatus::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ElectionStatus::code() const {
  // @@protoc_insertion_point(field_get:voting.ElectionStatus.code)
  return _internal_code();
}
inline void ElectionStatus::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  code_ = value;
}
inline void ElectionStatus::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:voting.ElectionStatus.code)
}

// -------------------------------------------------------------------

// Vote

// required string election_name = 1;
inline bool Vote::_internal_has_election_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Vote::has_election_name() const {
  return _internal_has_election_name();
}
inline void Vote::clear_election_name() {
  election_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Vote::election_name() const {
  // @@protoc_insertion_point(field_get:voting.Vote.election_name)
  return _internal_election_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Vote::set_election_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 election_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.Vote.election_name)
}
inline std::string* Vote::mutable_election_name() {
  std::string* _s = _internal_mutable_election_name();
  // @@protoc_insertion_point(field_mutable:voting.Vote.election_name)
  return _s;
}
inline const std::string& Vote::_internal_election_name() const {
  return election_name_.Get();
}
inline void Vote::_internal_set_election_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  election_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Vote::_internal_mutable_election_name() {
  _has_bits_[0] |= 0x00000001u;
  return election_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Vote::release_election_name() {
  // @@protoc_insertion_point(field_release:voting.Vote.election_name)
  if (!_internal_has_election_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return election_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Vote::set_allocated_election_name(std::string* election_name) {
  if (election_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  election_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), election_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:voting.Vote.election_name)
}

// required string choice_name = 2;
inline bool Vote::_internal_has_choice_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Vote::has_choice_name() const {
  return _internal_has_choice_name();
}
inline void Vote::clear_choice_name() {
  choice_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Vote::choice_name() const {
  // @@protoc_insertion_point(field_get:voting.Vote.choice_name)
  return _internal_choice_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Vote::set_choice_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 choice_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.Vote.choice_name)
}
inline std::string* Vote::mutable_choice_name() {
  std::string* _s = _internal_mutable_choice_name();
  // @@protoc_insertion_point(field_mutable:voting.Vote.choice_name)
  return _s;
}
inline const std::string& Vote::_internal_choice_name() const {
  return choice_name_.Get();
}
inline void Vote::_internal_set_choice_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  choice_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Vote::_internal_mutable_choice_name() {
  _has_bits_[0] |= 0x00000002u;
  return choice_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Vote::release_choice_name() {
  // @@protoc_insertion_point(field_release:voting.Vote.choice_name)
  if (!_internal_has_choice_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return choice_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Vote::set_allocated_choice_name(std::string* choice_name) {
  if (choice_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  choice_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), choice_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:voting.Vote.choice_name)
}

// required .voting.AuthToken token = 3;
inline bool Vote::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || token_ != nullptr);
  return value;
}
inline bool Vote::has_token() const {
  return _internal_has_token();
}
inline void Vote::clear_token() {
  if (token_ != nullptr) token_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::voting::AuthToken& Vote::_internal_token() const {
  const ::voting::AuthToken* p = token_;
  return p != nullptr ? *p : reinterpret_cast<const ::voting::AuthToken&>(
      ::voting::_AuthToken_default_instance_);
}
inline const ::voting::AuthToken& Vote::token() const {
  // @@protoc_insertion_point(field_get:voting.Vote.token)
  return _internal_token();
}
inline void Vote::unsafe_arena_set_allocated_token(
    ::voting::AuthToken* token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(token_);
  }
  token_ = token;
  if (token) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:voting.Vote.token)
}
inline ::voting::AuthToken* Vote::release_token() {
  _has_bits_[0] &= ~0x00000004u;
  ::voting::AuthToken* temp = token_;
  token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::voting::AuthToken* Vote::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_release:voting.Vote.token)
  _has_bits_[0] &= ~0x00000004u;
  ::voting::AuthToken* temp = token_;
  token_ = nullptr;
  return temp;
}
inline ::voting::AuthToken* Vote::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000004u;
  if (token_ == nullptr) {
    auto* p = CreateMaybeMessage<::voting::AuthToken>(GetArenaForAllocation());
    token_ = p;
  }
  return token_;
}
inline ::voting::AuthToken* Vote::mutable_token() {
  ::voting::AuthToken* _msg = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:voting.Vote.token)
  return _msg;
}
inline void Vote::set_allocated_token(::voting::AuthToken* token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete token_;
  }
  if (token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::voting::AuthToken>::GetOwningArena(token);
    if (message_arena != submessage_arena) {
      token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  token_ = token;
  // @@protoc_insertion_point(field_set_allocated:voting.Vote.token)
}

// -------------------------------------------------------------------

// AuthRequest

// required bytes value = 1;
inline bool AuthRequest::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AuthRequest::has_value() const {
  return _internal_has_value();
}
inline void AuthRequest::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AuthRequest::value() const {
  // @@protoc_insertion_point(field_get:voting.AuthRequest.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthRequest::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.AuthRequest.value)
}
inline std::string* AuthRequest::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:voting.AuthRequest.value)
  return _s;
}
inline const std::string& AuthRequest::_internal_value() const {
  return value_.Get();
}
inline void AuthRequest::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AuthRequest::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AuthRequest::release_value() {
  // @@protoc_insertion_point(field_release:voting.AuthRequest.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AuthRequest::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:voting.AuthRequest.value)
}

// -------------------------------------------------------------------

// ElectionName

// required string name = 1;
inline bool ElectionName::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ElectionName::has_name() const {
  return _internal_has_name();
}
inline void ElectionName::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ElectionName::name() const {
  // @@protoc_insertion_point(field_get:voting.ElectionName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ElectionName::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.ElectionName.name)
}
inline std::string* ElectionName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:voting.ElectionName.name)
  return _s;
}
inline const std::string& ElectionName::_internal_name() const {
  return name_.Get();
}
inline void ElectionName::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ElectionName::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ElectionName::release_name() {
  // @@protoc_insertion_point(field_release:voting.ElectionName.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ElectionName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:voting.ElectionName.name)
}

// -------------------------------------------------------------------

// VoteCount

// required string choice_name = 1;
inline bool VoteCount::_internal_has_choice_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VoteCount::has_choice_name() const {
  return _internal_has_choice_name();
}
inline void VoteCount::clear_choice_name() {
  choice_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VoteCount::choice_name() const {
  // @@protoc_insertion_point(field_get:voting.VoteCount.choice_name)
  return _internal_choice_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VoteCount::set_choice_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 choice_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:voting.VoteCount.choice_name)
}
inline std::string* VoteCount::mutable_choice_name() {
  std::string* _s = _internal_mutable_choice_name();
  // @@protoc_insertion_point(field_mutable:voting.VoteCount.choice_name)
  return _s;
}
inline const std::string& VoteCount::_internal_choice_name() const {
  return choice_name_.Get();
}
inline void VoteCount::_internal_set_choice_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  choice_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VoteCount::_internal_mutable_choice_name() {
  _has_bits_[0] |= 0x00000001u;
  return choice_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VoteCount::release_choice_name() {
  // @@protoc_insertion_point(field_release:voting.VoteCount.choice_name)
  if (!_internal_has_choice_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return choice_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VoteCount::set_allocated_choice_name(std::string* choice_name) {
  if (choice_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  choice_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), choice_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:voting.VoteCount.choice_name)
}

// required int32 count = 2;
inline bool VoteCount::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VoteCount::has_count() const {
  return _internal_has_count();
}
inline void VoteCount::clear_count() {
  count_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VoteCount::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VoteCount::count() const {
  // @@protoc_insertion_point(field_get:voting.VoteCount.count)
  return _internal_count();
}
inline void VoteCount::_internal_set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  count_ = value;
}
inline void VoteCount::set_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:voting.VoteCount.count)
}

// required .voting.AuthToken token = 3;
inline bool VoteCount::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || token_ != nullptr);
  return value;
}
inline bool VoteCount::has_token() const {
  return _internal_has_token();
}
inline void VoteCount::clear_token() {
  if (token_ != nullptr) token_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::voting::AuthToken& VoteCount::_internal_token() const {
  const ::voting::AuthToken* p = token_;
  return p != nullptr ? *p : reinterpret_cast<const ::voting::AuthToken&>(
      ::voting::_AuthToken_default_instance_);
}
inline const ::voting::AuthToken& VoteCount::token() const {
  // @@protoc_insertion_point(field_get:voting.VoteCount.token)
  return _internal_token();
}
inline void VoteCount::unsafe_arena_set_allocated_token(
    ::voting::AuthToken* token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(token_);
  }
  token_ = token;
  if (token) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:voting.VoteCount.token)
}
inline ::voting::AuthToken* VoteCount::release_token() {
  _has_bits_[0] &= ~0x00000002u;
  ::voting::AuthToken* temp = token_;
  token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::voting::AuthToken* VoteCount::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_release:voting.VoteCount.token)
  _has_bits_[0] &= ~0x00000002u;
  ::voting::AuthToken* temp = token_;
  token_ = nullptr;
  return temp;
}
inline ::voting::AuthToken* VoteCount::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000002u;
  if (token_ == nullptr) {
    auto* p = CreateMaybeMessage<::voting::AuthToken>(GetArenaForAllocation());
    token_ = p;
  }
  return token_;
}
inline ::voting::AuthToken* VoteCount::mutable_token() {
  ::voting::AuthToken* _msg = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:voting.VoteCount.token)
  return _msg;
}
inline void VoteCount::set_allocated_token(::voting::AuthToken* token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete token_;
  }
  if (token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::voting::AuthToken>::GetOwningArena(token);
    if (message_arena != submessage_arena) {
      token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  token_ = token;
  // @@protoc_insertion_point(field_set_allocated:voting.VoteCount.token)
}

// -------------------------------------------------------------------

// ElectionResult

// required int32 status = 1;
inline bool ElectionResult::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ElectionResult::has_status() const {
  return _internal_has_status();
}
inline void ElectionResult::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ElectionResult::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ElectionResult::status() const {
  // @@protoc_insertion_point(field_get:voting.ElectionResult.status)
  return _internal_status();
}
inline void ElectionResult::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void ElectionResult::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:voting.ElectionResult.status)
}

// repeated .voting.VoteCount count = 2;
inline int ElectionResult::_internal_count_size() const {
  return count_.size();
}
inline int ElectionResult::count_size() const {
  return _internal_count_size();
}
inline void ElectionResult::clear_count() {
  count_.Clear();
}
inline ::voting::VoteCount* ElectionResult::mutable_count(int index) {
  // @@protoc_insertion_point(field_mutable:voting.ElectionResult.count)
  return count_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::VoteCount >*
ElectionResult::mutable_count() {
  // @@protoc_insertion_point(field_mutable_list:voting.ElectionResult.count)
  return &count_;
}
inline const ::voting::VoteCount& ElectionResult::_internal_count(int index) const {
  return count_.Get(index);
}
inline const ::voting::VoteCount& ElectionResult::count(int index) const {
  // @@protoc_insertion_point(field_get:voting.ElectionResult.count)
  return _internal_count(index);
}
inline ::voting::VoteCount* ElectionResult::_internal_add_count() {
  return count_.Add();
}
inline ::voting::VoteCount* ElectionResult::add_count() {
  ::voting::VoteCount* _add = _internal_add_count();
  // @@protoc_insertion_point(field_add:voting.ElectionResult.count)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::voting::VoteCount >&
ElectionResult::count() const {
  // @@protoc_insertion_point(field_list:voting.ElectionResult.count)
  return count_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace voting

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_evoting_2eproto
